-- Arquivo: supabase/migrations/003_functions_and_triggers.sql
-- Descrição: Cria todas as funções (RPC) e os gatilhos (Triggers) da aplicação.

--------------------------------------------------------------------------------
-- 5. FUNÇÕES (RPC)
--------------------------------------------------------------------------------

-- Funções Auxiliares
CREATE OR REPLACE FUNCTION normalize_text(p_text TEXT) RETURNS TEXT AS $$ BEGIN RETURN trim(regexp_replace(lower(unaccent(p_text)), '\s+', ' ', 'g')); END; $$ LANGUAGE plpgsql IMMUTABLE;
CREATE OR REPLACE FUNCTION proper_case(p_text TEXT) RETURNS TEXT AS $$ BEGIN RETURN initcap(p_text); END; $$ LANGUAGE plpgsql IMMUTABLE;
CREATE OR REPLACE FUNCTION get_my_role() RETURNS TEXT AS $$ BEGIN RETURN (SELECT role FROM public.employees WHERE id = auth.uid()); END; $$ LANGUAGE plpgsql SECURITY DEFINER;

-- Funções de Gestão de Endereços
CREATE OR REPLACE FUNCTION create_or_update_address(p_address_id UUID, p_cep TEXT, p_street_name TEXT, p_neighborhood TEXT, p_city_id INT) RETURNS UUID LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE new_address_id UUID; BEGIN IF p_address_id IS NOT NULL THEN UPDATE public.addresses SET cep=p_cep, street_name=p_street_name, neighborhood=p_neighborhood, city_id=p_city_id, updated_at=NOW() WHERE id = p_address_id RETURNING id INTO new_address_id; ELSE INSERT INTO public.addresses (cep, street_name, neighborhood, city_id) VALUES (p_cep, p_street_name, p_neighborhood, p_city_id) RETURNING id INTO new_address_id; END IF; RETURN new_address_id; END; $$;
CREATE OR REPLACE FUNCTION delete_address(p_address_id UUID) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF EXISTS (SELECT 1 FROM public.customers WHERE address_id = p_address_id) THEN RAISE EXCEPTION 'Endereço em uso por um cliente.'; END IF; DELETE FROM public.addresses WHERE id = p_address_id; END; $$;
CREATE OR REPLACE FUNCTION find_or_create_address_by_cep(p_cep TEXT, p_street_name TEXT, p_neighborhood TEXT, p_city_name TEXT, p_state_uf TEXT) RETURNS UUID LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE v_address_id UUID; v_city_id INT; BEGIN SELECT id INTO v_address_id FROM public.addresses WHERE cep = p_cep AND street_name = p_street_name LIMIT 1; IF v_address_id IS NOT NULL THEN RETURN v_address_id; END IF; SELECT c.id INTO v_city_id FROM public.cities c JOIN public.states s ON c.state_id = s.id WHERE c.name ILIKE p_city_name AND s.uf = p_state_uf LIMIT 1; IF v_city_id IS NULL THEN RAISE EXCEPTION 'Cidade ou Estado não encontrado: %, %', p_city_name, p_state_uf; END IF; INSERT INTO public.addresses (cep, street_name, neighborhood, city_id) VALUES (p_cep, p_street_name, p_neighborhood, v_city_id) RETURNING id INTO v_address_id; RETURN v_address_id; END; $$;
CREATE OR REPLACE FUNCTION count_addresses() RETURNS INT LANGUAGE plpgsql AS $$ DECLARE v_count INT; BEGIN SELECT COUNT(*) INTO v_count FROM public.addresses; RETURN v_count; END; $$;

-- Funções de Gestão de Clientes
CREATE OR REPLACE FUNCTION create_or_update_customer(p_customer_id UUID, p_full_name TEXT, p_cpf TEXT, p_cellphone TEXT, p_birth_date DATE, p_contact_customer_id UUID, p_email TEXT, p_address_id UUID, p_address_number TEXT, p_address_complement TEXT) RETURNS customers LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE result_customer customers; BEGIN IF p_customer_id IS NOT NULL THEN UPDATE public.customers SET full_name=p_full_name, cpf=p_cpf, cellphone=p_cellphone, birth_date=p_birth_date, contact_customer_id=p_contact_customer_id, email=p_email, address_id=p_address_id, address_number=p_address_number, address_complement=p_address_complement, updated_at=NOW() WHERE id = p_customer_id RETURNING * INTO result_customer; ELSE INSERT INTO public.customers (full_name, cpf, cellphone, birth_date, contact_customer_id, email, address_id, address_number, address_complement) VALUES (p_full_name, p_cpf, p_cellphone, p_birth_date, p_contact_customer_id, p_email, p_address_id, p_address_number, p_address_complement) RETURNING * INTO result_customer; END IF; RETURN result_customer; END; $$;
CREATE OR REPLACE FUNCTION set_customer_status(p_customer_id UUID, p_is_active BOOLEAN) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN WITH RECURSIVE customer_hierarchy AS (SELECT id FROM public.customers WHERE id = p_customer_id UNION ALL SELECT c.id FROM public.customers c INNER JOIN customer_hierarchy ch ON c.contact_customer_id = ch.id) UPDATE public.customers SET is_active = p_is_active WHERE id IN (SELECT id FROM customer_hierarchy); END; $$;
CREATE OR REPLACE FUNCTION count_customers_filtered(p_search_term TEXT, p_status_filter TEXT) RETURNS INT LANGUAGE plpgsql AS $$ DECLARE v_count INT; query TEXT; search_pattern TEXT; BEGIN query := 'SELECT COUNT(*) FROM public.customers WHERE TRUE'; IF p_search_term IS NOT NULL AND p_search_term <> '' THEN search_pattern := '%' || p_search_term || '%'; query := query || format(' AND (unaccent(full_name) ILIKE unaccent(%L) OR cpf ILIKE %L OR cellphone ILIKE %L)', search_pattern, search_pattern, search_pattern); END IF; IF p_status_filter = 'active' THEN query := query || ' AND is_active = TRUE'; ELSIF p_status_filter = 'inactive' THEN query := query || ' AND is_active = FALSE'; END IF; EXECUTE query INTO v_count; RETURN v_count; END; $$;
CREATE OR REPLACE FUNCTION search_contacts(p_search_term TEXT) RETURNS TABLE (id UUID, full_name TEXT) LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN RETURN QUERY SELECT c.id, c.full_name FROM public.customers c WHERE c.is_active = TRUE AND c.cellphone IS NOT NULL AND normalize_text(c.full_name) ILIKE normalize_text('%' || p_search_term || '%') ORDER BY c.full_name LIMIT 20; END; $$;

-- Funções de Gestão de Objetos
CREATE OR REPLACE FUNCTION create_or_update_object(p_recipient_name TEXT, p_object_type TEXT, p_tracking_code TEXT DEFAULT NULL, p_control_number INT DEFAULT NULL, p_cep TEXT DEFAULT NULL, p_street_name TEXT DEFAULT NULL, p_number TEXT DEFAULT NULL, p_neighborhood TEXT DEFAULT NULL, p_city_name TEXT DEFAULT NULL, p_state_uf TEXT DEFAULT NULL) RETURNS objects LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE v_customer_id UUID; v_address_id UUID; v_city_id INT; v_storage_deadline DATE; v_storage_days INT; result_object objects; BEGIN SELECT default_storage_days INTO v_storage_days FROM public.object_types WHERE name = p_object_type; IF NOT FOUND THEN v_storage_days := 20; END IF; v_storage_deadline := CURRENT_DATE + (v_storage_days || ' days')::INTERVAL; SELECT id INTO v_customer_id FROM public.customers WHERE normalize_text(full_name) = normalize_text(p_recipient_name) LIMIT 1; IF p_street_name IS NOT NULL AND p_city_name IS NOT NULL THEN SELECT c.id INTO v_city_id FROM public.cities c JOIN public.states s ON c.state_id = s.id WHERE c.name ILIKE p_city_name AND s.uf ILIKE p_state_uf LIMIT 1; IF v_city_id IS NULL THEN RAISE EXCEPTION 'Cidade ou Estado não encontrado: %, %', p_city_name, p_state_uf; END IF; INSERT INTO public.addresses (cep, street_name, neighborhood, city_id) VALUES (p_cep, p_street_name, p_neighborhood, v_city_id) ON CONFLICT DO NOTHING; SELECT id INTO v_address_id FROM public.addresses WHERE street_name=p_street_name AND city_id=v_city_id; ELSE v_address_id := NULL; END IF; IF p_control_number IS NOT NULL THEN UPDATE public.objects SET recipient_name=p_recipient_name, object_type=p_object_type, tracking_code=p_tracking_code, customer_id=v_customer_id, updated_at=NOW() WHERE control_number = p_control_number RETURNING * INTO result_object; ELSE INSERT INTO public.objects (recipient_name, object_type, storage_deadline, tracking_code, customer_id, delivery_address_id) VALUES (p_recipient_name, p_object_type, v_storage_deadline, p_tracking_code, v_customer_id, v_address_id) RETURNING * INTO result_object; END IF; RETURN result_object; END; $$;
CREATE OR REPLACE FUNCTION deliver_object(p_control_number INT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN UPDATE public.objects SET status = 'Entregue', updated_at = NOW() WHERE control_number = p_control_number AND status = 'Aguardando Retirada'; END; $$;
CREATE OR REPLACE FUNCTION return_object(p_control_number INT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN UPDATE public.objects SET status = 'Devolvido', updated_at = NOW() WHERE control_number = p_control_number AND status = 'Aguardando Retirada'; END; $$;
CREATE OR REPLACE FUNCTION archive_completed_objects() RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; UPDATE public.objects SET is_archived = TRUE WHERE status IN ('Entregue', 'Devolvido') AND is_archived = FALSE; END; $$;
CREATE OR REPLACE FUNCTION unarchive_object(p_control_number INT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; UPDATE public.objects SET status = 'Aguardando Retirada', is_archived = FALSE WHERE control_number = p_control_number; END; $$;

-- Funções de Inserção em Massa
CREATE OR REPLACE FUNCTION bulk_create_simple_objects(p_object_type TEXT, p_objects simple_object_input[]) RETURNS TABLE (report_recipient_name TEXT, report_control_number INT) LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE obj simple_object_input; v_recipient_name TEXT; v_street_name TEXT; v_address_id UUID; v_city_id INT; v_customer_id UUID; v_storage_deadline DATE; v_new_control_number INT; v_storage_days INT; BEGIN SELECT id INTO v_city_id FROM cities WHERE name = 'América Dourada' LIMIT 1; IF v_city_id IS NULL THEN RAISE EXCEPTION 'A cidade padrão "América Dourada" não foi encontrada.'; END IF; SELECT default_storage_days INTO v_storage_days FROM public.object_types WHERE name = p_object_type; IF NOT FOUND THEN v_storage_days := 20; END IF; v_storage_deadline := CURRENT_DATE + (v_storage_days || ' days')::INTERVAL; FOREACH obj IN ARRAY p_objects LOOP v_recipient_name := proper_case(obj.recipient_name); v_street_name := proper_case(obj.street_name); SELECT id INTO v_address_id FROM addresses WHERE normalize_text(street_name) = normalize_text(v_street_name) AND city_id = v_city_id LIMIT 1; IF v_address_id IS NULL THEN INSERT INTO addresses (street_name, city_id) VALUES (v_street_name, v_city_id) RETURNING id INTO v_address_id; END IF; SELECT id INTO v_customer_id FROM customers WHERE normalize_text(full_name) = normalize_text(v_recipient_name) LIMIT 1; INSERT INTO public.objects (recipient_name, object_type, storage_deadline, customer_id, delivery_address_id) VALUES (v_recipient_name, p_object_type, v_storage_deadline, v_customer_id, v_address_id) RETURNING control_number INTO v_new_control_number; report_recipient_name := v_recipient_name; report_control_number := v_new_control_number; RETURN NEXT; END LOOP; RETURN; END; $$;
CREATE OR REPLACE FUNCTION bulk_create_registered_objects(p_objects registered_object_input[]) RETURNS TABLE (report_recipient_name TEXT, report_control_number INT, report_tracking_code TEXT) LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE obj registered_object_input; v_rule RECORD; v_recipient_name TEXT; v_street_name TEXT; v_address_number TEXT; v_address_complement TEXT; v_address_id UUID; v_city_id INT; v_customer_id UUID; v_storage_deadline DATE; v_new_control_number INT; BEGIN SELECT id INTO v_city_id FROM cities WHERE name = 'América Dourada' LIMIT 1; IF v_city_id IS NULL THEN RAISE EXCEPTION 'A cidade padrão "América Dourada" não foi encontrada.'; END IF; FOREACH obj IN ARRAY p_objects LOOP SELECT * INTO v_rule FROM public.tracking_code_rules WHERE upper(obj.tracking_code) LIKE upper(prefix) || '%'; IF NOT FOUND THEN v_storage_deadline := CURRENT_DATE + INTERVAL '7 days'; ELSE v_storage_deadline := CURRENT_DATE + (v_rule.storage_days || ' days')::INTERVAL; END IF; v_recipient_name := proper_case(obj.recipient_name); v_street_name := proper_case(obj.street_name); v_address_number := obj.address_number; v_address_complement := obj.address_complement; SELECT id INTO v_address_id FROM addresses WHERE normalize_text(street_name) = normalize_text(v_street_name) AND city_id = v_city_id LIMIT 1; IF v_address_id IS NULL THEN INSERT INTO addresses (street_name, city_id) VALUES (v_street_name, v_city_id) RETURNING id INTO v_address_id; END IF; SELECT id INTO v_customer_id FROM customers WHERE normalize_text(full_name) = normalize_text(v_recipient_name) LIMIT 1; IF v_customer_id IS NULL THEN INSERT INTO public.customers (full_name, address_id, address_number, address_complement) VALUES (v_recipient_name, v_address_id, v_address_number, v_address_complement) RETURNING id INTO v_customer_id; ELSE UPDATE public.customers SET address_id = v_address_id, address_number = v_address_number, address_complement = v_address_complement WHERE id = v_customer_id; END IF; INSERT INTO public.objects (recipient_name, object_type, tracking_code, storage_deadline, customer_id, delivery_address_id) VALUES (v_recipient_name, obj.object_type, upper(obj.tracking_code), v_storage_deadline, v_customer_id, v_address_id) RETURNING control_number INTO v_new_control_number; report_recipient_name := v_recipient_name; report_control_number := v_new_control_number; report_tracking_code := upper(obj.tracking_code); RETURN NEXT; END LOOP; RETURN; END; $$;

-- Funções de Gestão de Estoque
CREATE OR REPLACE FUNCTION create_or_update_supply(p_supply_id UUID, p_name TEXT, p_description TEXT, p_initial_stock INT DEFAULT 0) RETURNS office_supplies LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE result_supply office_supplies; BEGIN IF p_supply_id IS NOT NULL THEN UPDATE public.office_supplies SET name = p_name, description = p_description, updated_at = NOW() WHERE id = p_supply_id RETURNING * INTO result_supply; ELSE INSERT INTO public.office_supplies (name, description, stock) VALUES (p_name, p_description, p_initial_stock) RETURNING * INTO result_supply; END IF; RETURN result_supply; END; $$;
CREATE OR REPLACE FUNCTION log_and_adjust_stock(p_supply_id UUID, p_quantity_change INT, p_reason TEXT) RETURNS INT LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE v_new_stock INT; BEGIN UPDATE public.office_supplies SET stock = stock + p_quantity_change WHERE id = p_supply_id AND stock + p_quantity_change >= 0 RETURNING stock INTO v_new_stock; IF NOT FOUND THEN RAISE EXCEPTION 'Falha ao atualizar o estoque. O resultado não pode ser negativo.'; END IF; INSERT INTO public.supply_stock_log (supply_id, user_id, quantity_changed, new_stock_total, reason) VALUES (p_supply_id, auth.uid(), p_quantity_change, v_new_stock, p_reason); RETURN v_new_stock; END; $$;
CREATE OR REPLACE FUNCTION count_supplies() RETURNS INT LANGUAGE plpgsql AS $$ DECLARE v_count INT; BEGIN SELECT COUNT(*) INTO v_count FROM public.office_supplies; RETURN v_count; END; $$;

-- Funções de Gestão de Links
CREATE OR REPLACE FUNCTION create_or_update_link(p_link_id UUID, p_name TEXT, p_url TEXT, p_description TEXT, p_details TEXT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF p_link_id IS NOT NULL THEN UPDATE public.system_links SET name = p_name, url = p_url, description = p_description, details = p_details, updated_at = NOW() WHERE id = p_link_id; ELSE INSERT INTO public.system_links (name, url, description, details) VALUES (p_name, p_url, p_description, p_details); END IF; END; $$;
CREATE OR REPLACE FUNCTION delete_link(p_link_id UUID) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN DELETE FROM public.system_links WHERE id = p_link_id; END; $$;
CREATE OR REPLACE FUNCTION count_links() RETURNS INT LANGUAGE plpgsql AS $$ DECLARE v_count INT; BEGIN SELECT COUNT(*) INTO v_count FROM public.system_links; RETURN v_count; END; $$;

-- Funções de Gestão de Temas e Configurações
CREATE OR REPLACE FUNCTION save_user_theme(p_theme_name TEXT, p_theme_colors JSONB) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN INSERT INTO public.user_themes (user_id, theme_name, theme_colors) VALUES (auth.uid(), p_theme_name, p_theme_colors) ON CONFLICT (user_id, theme_name) DO UPDATE SET theme_colors = EXCLUDED.theme_colors, created_at = NOW(); END; $$;
CREATE OR REPLACE FUNCTION delete_user_theme(p_theme_id UUID) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN DELETE FROM public.user_themes WHERE id = p_theme_id AND user_id = auth.uid(); END; $$;
CREATE OR REPLACE FUNCTION create_or_update_app_setting(p_key TEXT, p_value TEXT, p_description TEXT, p_label TEXT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; INSERT INTO public.app_settings (key, value, description, label) VALUES (p_key, p_value, p_description, p_label) ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value, description = EXCLUDED.description, label = EXCLUDED.label; END; $$;
CREATE OR REPLACE FUNCTION delete_app_setting(p_key TEXT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; IF p_key IN ('agency_name', 'agency_dh', 'agency_mcu', 'agency_sto', 'agency_address') THEN RAISE EXCEPTION 'Esta configuração não pode ser apagada.'; END IF; DELETE FROM public.app_settings WHERE key = p_key; END; $$;

-- Funções de Gestão de Funcionários
CREATE OR REPLACE FUNCTION get_employee_profiles() RETURNS TABLE (id UUID, full_name TEXT, registration_number VARCHAR, role TEXT) LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem visualizar perfis.'; END IF; RETURN QUERY SELECT e.id, e.full_name, e.registration_number, e.role FROM public.employees e; END; $$;
CREATE OR REPLACE FUNCTION delete_employee(p_user_id UUID) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem apagar usuários.'; END IF; DELETE FROM auth.users WHERE id = p_user_id; END; $$;

-- Funções de Gestão de Regras e Tipos
CREATE OR REPLACE FUNCTION create_or_update_tracking_rule(p_rule_id INT, p_prefix TEXT, p_object_type TEXT, p_storage_days INT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; IF p_rule_id IS NOT NULL THEN UPDATE public.tracking_code_rules SET prefix=p_prefix, object_type=p_object_type, storage_days=p_storage_days WHERE id = p_rule_id; ELSE INSERT INTO public.tracking_code_rules (prefix, object_type, storage_days) VALUES (p_prefix, p_object_type, p_storage_days); END IF; END; $$;
CREATE OR REPLACE FUNCTION delete_tracking_rule(p_rule_id INT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; DELETE FROM public.tracking_code_rules WHERE id = p_rule_id; END; $$;
CREATE OR REPLACE FUNCTION create_or_update_object_type(p_type_id INT, p_name TEXT, p_default_storage_days INT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; IF p_type_id IS NOT NULL THEN UPDATE public.object_types SET name=p_name, default_storage_days=p_default_storage_days WHERE id = p_type_id; ELSE INSERT INTO public.object_types (name, default_storage_days) VALUES (p_name, p_default_storage_days); END IF; END; $$;
CREATE OR REPLACE FUNCTION delete_object_type(p_type_id INT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; DELETE FROM public.object_types WHERE id = p_type_id; END; $$;

-- Funções de Gestão de Tarefas
CREATE OR REPLACE FUNCTION create_or_update_task(p_task_id INT, p_title TEXT, p_description TEXT, p_frequency_type TEXT, p_due_date DATE DEFAULT NULL) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; IF p_task_id IS NOT NULL THEN UPDATE public.tasks SET title = p_title, description = p_description, frequency_type = p_frequency_type, due_date = p_due_date WHERE id = p_task_id; ELSE INSERT INTO public.tasks (title, description, frequency_type, due_date) VALUES (p_title, p_description, p_frequency_type, p_due_date); END IF; END; $$;
CREATE OR REPLACE FUNCTION delete_task(p_task_id INT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN IF get_my_role() <> 'admin' THEN RAISE EXCEPTION 'Apenas administradores podem executar esta ação.'; END IF; DELETE FROM public.task_completions WHERE task_id = p_task_id; DELETE FROM public.tasks WHERE id = p_task_id; END; $$;
CREATE OR REPLACE FUNCTION complete_task(p_task_id INT) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN INSERT INTO public.task_completions (task_id, user_id) VALUES (p_task_id, auth.uid()); END; $$;

-- Funções de Consulta e Relatórios
CREATE OR REPLACE FUNCTION get_pending_tasks() RETURNS TABLE (id INT, title TEXT, description TEXT, frequency_type TEXT, due_date DATE, last_completed_at TIMESTAMPTZ) LANGUAGE plpgsql AS $$ BEGIN RETURN QUERY SELECT t.id, t.title, t.description, t.frequency_type, t.due_date, (SELECT MAX(tc.completed_at) FROM task_completions tc WHERE tc.task_id = t.id) AS last_completed_at FROM public.tasks t WHERE t.is_active = TRUE AND ((t.frequency_type = 'daily' AND EXTRACT(ISODOW FROM CURRENT_DATE) BETWEEN 1 AND 5 AND NOT EXISTS (SELECT 1 FROM task_completions tc WHERE tc.task_id = t.id AND tc.completed_at::date = CURRENT_DATE)) OR (t.frequency_type = 'weekly' AND ((SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id) IS NULL OR (SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id) < NOW() - INTERVAL '7 days')) OR (t.frequency_type = 'monthly' AND ((SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id) IS NULL OR (EXTRACT(YEAR FROM (SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id)) * 12 + EXTRACT(MONTH FROM (SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id))) < (EXTRACT(YEAR FROM CURRENT_DATE) * 12 + EXTRACT(MONTH FROM CURRENT_DATE)))) OR (t.frequency_type = 'quarterly' AND ((SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id) IS NULL OR (SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id) < NOW() - INTERVAL '3 months')) OR (t.frequency_type = 'semiannual' AND ((SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id) IS NULL OR (SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id) < NOW() - INTERVAL '6 months')) OR (t.frequency_type = 'annual' AND ((SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id) IS NULL OR (SELECT MAX(completed_at) FROM task_completions WHERE task_id = t.id) < NOW() - INTERVAL '1 year')) OR (t.frequency_type = 'once' AND t.due_date >= CURRENT_DATE AND NOT EXISTS (SELECT 1 FROM task_completions tc WHERE tc.task_id = t.id))) ORDER BY t.frequency_type, t.title; END; $$;
CREATE OR REPLACE FUNCTION get_dashboard_data() RETURNS JSON LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE v_awaiting_objects_count INT; v_expiring_soon_count INT; v_low_stock_count INT; v_recent_objects JSON; v_upcoming_birthdays JSON; v_pending_tasks JSON; BEGIN SELECT COUNT(*) INTO v_awaiting_objects_count FROM public.objects WHERE status = 'Aguardando Retirada' AND is_archived = FALSE; SELECT COUNT(*) INTO v_expiring_soon_count FROM public.objects WHERE status = 'Aguardando Retirada' AND is_archived = FALSE AND storage_deadline BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '3 days'); SELECT COUNT(*) INTO v_low_stock_count FROM public.office_supplies WHERE stock <= 5; SELECT json_agg(t) INTO v_recent_objects FROM (SELECT control_number, recipient_name, object_type, arrival_date FROM public.objects ORDER BY arrival_date DESC, created_at DESC LIMIT 5) t; SELECT json_agg(b) INTO v_upcoming_birthdays FROM (SELECT id, full_name, birth_date FROM public.customers WHERE is_active = TRUE AND birth_date IS NOT NULL) b; SELECT json_agg(pt.*) INTO v_pending_tasks FROM get_pending_tasks() pt; RETURN json_build_object('awaiting_count', v_awaiting_objects_count, 'expiring_count', v_expiring_soon_count, 'low_stock_count', v_low_stock_count, 'recent_objects', COALESCE(v_recent_objects, '[]'::json), 'upcoming_birthdays', COALESCE(v_upcoming_birthdays, '[]'::json), 'pending_tasks', COALESCE(v_pending_tasks, '[]'::json)); END; $$;
CREATE OR REPLACE FUNCTION get_customer_details(p_customer_id UUID) RETURNS JSON LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE v_customer_profile JSON; v_customer_objects JSON; v_this_customer_is_contact_for JSON; v_contacts_for_this_customer JSON; v_main_contact_associations JSON; BEGIN SELECT json_build_object('id', c.id, 'full_name', c.full_name, 'cpf', c.cpf, 'cellphone', c.cellphone, 'birth_date', c.birth_date, 'is_active', c.is_active, 'contact_customer_id', c.contact_customer_id, 'email', c.email, 'address_id', c.address_id, 'address_number', c.address_number, 'address_complement', c.address_complement, 'address', json_build_object('street_name', a.street_name, 'neighborhood', a.neighborhood, 'cep', a.cep, 'city', ci.name, 'state', s.uf)) INTO v_customer_profile FROM public.customers c LEFT JOIN public.addresses a ON c.address_id = a.id LEFT JOIN public.cities ci ON a.city_id = ci.id LEFT JOIN public.states s ON ci.state_id = s.id WHERE c.id = p_customer_id; SELECT json_agg(o.*) INTO v_customer_objects FROM public.objects o WHERE normalize_text(o.recipient_name) = normalize_text((SELECT full_name FROM public.customers WHERE id = p_customer_id)); SELECT json_agg(json_build_object('id', dep.id, 'full_name', dep.full_name)) INTO v_this_customer_is_contact_for FROM public.customers dep WHERE dep.contact_customer_id = p_customer_id; SELECT json_agg(json_build_object('id', main.id, 'full_name', main.full_name, 'contact_customer_id', main.contact_customer_id)) INTO v_contacts_for_this_customer FROM public.customers main WHERE main.id = (SELECT contact_customer_id FROM public.customers WHERE id = p_customer_id); SELECT json_agg(json_build_object('id', dep_main.id, 'full_name', dep_main.full_name)) INTO v_main_contact_associations FROM public.customers dep_main WHERE dep_main.contact_customer_id = (SELECT contact_customer_id FROM public.customers WHERE id = p_customer_id); RETURN json_build_object('profile', v_customer_profile, 'objects', COALESCE(v_customer_objects, '[]'::json), 'this_customer_is_contact_for', COALESCE(v_this_customer_is_contact_for, '[]'::json), 'contacts_for_this_customer', COALESCE(v_contacts_for_this_customer, '[]'::json), 'main_contact_associations', COALESCE(v_main_contact_associations, '[]'::json)); END; $$;
CREATE OR REPLACE FUNCTION get_supply_stock_log(p_supply_id UUID, p_start_date DATE) RETURNS TABLE (id BIGINT, quantity_changed INT, new_stock_total INT, reason TEXT, created_at TIMESTAMPTZ, user_id UUID) LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN RETURN QUERY SELECT l.id, l.quantity_changed, l.new_stock_total, l.reason, l.created_at, l.user_id FROM public.supply_stock_log l WHERE l.supply_id = p_supply_id AND l.created_at >= p_start_date ORDER BY l.created_at DESC; END; $$;
CREATE OR REPLACE FUNCTION get_phones_for_recipients(p_recipient_names TEXT[]) RETURNS JSONB LANGUAGE plpgsql AS $$ DECLARE v_name TEXT; v_phone TEXT; v_result JSONB := '{}'::jsonb; v_customer RECORD; v_contact_customer RECORD; BEGIN FOREACH v_name IN ARRAY p_recipient_names LOOP v_phone := NULL; SELECT * INTO v_customer FROM public.customers WHERE normalize_text(full_name) = normalize_text(v_name) AND is_active = TRUE LIMIT 1; IF FOUND THEN IF v_customer.cellphone IS NOT NULL THEN v_phone := v_customer.cellphone; ELSIF v_customer.contact_customer_id IS NOT NULL THEN SELECT * INTO v_contact_customer FROM public.customers WHERE id = v_customer.contact_customer_id AND is_active = TRUE; IF FOUND AND v_contact_customer.cellphone IS NOT NULL THEN v_phone := v_contact_customer.cellphone; END IF; END IF; END IF; v_result := v_result || jsonb_build_object(v_name, v_phone); END LOOP; RETURN v_result; END; $$;
CREATE OR REPLACE FUNCTION save_bulk_report(p_report_data JSONB) RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN INSERT INTO public.bulk_import_reports (user_id, report_data) VALUES (auth.uid(), p_report_data); END; $$;
CREATE OR REPLACE FUNCTION get_notifications() RETURNS JSON LANGUAGE plpgsql AS $$ DECLARE notifications_json JSON; BEGIN IF (SELECT get_my_role()) <> 'admin' THEN RETURN '[]'::json; END IF; SELECT json_agg(n) INTO notifications_json FROM (SELECT 'stock' AS type, 'Estoque baixo: ' || name AS message, '/supplies' AS link, id::text AS unique_id FROM public.office_supplies WHERE stock <= 5 UNION ALL SELECT 'task' AS type, 'Tarefa pendente: ' || title AS message, '/tasks' AS link, id::text AS unique_id FROM get_pending_tasks() UNION ALL SELECT 'object' AS type, 'Objeto para ' || recipient_name || ' vence em ' || to_char(storage_deadline, 'DD/MM') AS message, '/objects' AS link, control_number::text AS unique_id FROM public.objects WHERE status = 'Aguardando Retirada' AND is_archived = FALSE AND storage_deadline BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '3 days')) n; RETURN COALESCE(notifications_json, '[]'::json); END; $$;
CREATE OR REPLACE FUNCTION get_monthly_objects_report(p_year INT) RETURNS JSON LANGUAGE plpgsql AS $$ DECLARE report_data JSON; BEGIN IF (SELECT get_my_role()) <> 'admin' THEN RETURN '[]'::json; END IF; WITH months AS (SELECT generate_series(make_date(p_year, 1, 1), make_date(p_year, 12, 1), '1 month')::date AS month_start), monthly_stats AS (SELECT date_trunc('month', o.created_at)::date AS month, COUNT(*) AS criados, COUNT(*) FILTER (WHERE o.status = 'Entregue') AS entregues, COUNT(*) FILTER (WHERE o.status = 'Devolvido') AS devolvidos FROM public.objects o WHERE EXTRACT(YEAR FROM o.created_at) = p_year GROUP BY month) SELECT json_agg(t.*) INTO report_data FROM (SELECT to_char(m.month_start, 'Mon') AS mes, COALESCE(ms.criados, 0)::int AS criados, COALESCE(ms.entregues, 0)::int AS entregues, COALESCE(ms.devolvidos, 0)::int AS devolvidos FROM months m LEFT JOIN monthly_stats ms ON m.month_start = ms.month ORDER BY m.month_start) t; RETURN COALESCE(report_data, '[]'::json); END; $$;
CREATE OR REPLACE FUNCTION get_supplies_usage_report(p_months INT DEFAULT 3) RETURNS JSON LANGUAGE plpgsql AS $$ DECLARE report_data JSON; v_start_date DATE; BEGIN IF (SELECT get_my_role()) <> 'admin' THEN RETURN '[]'::json; END IF; v_start_date := (NOW() - (p_months || ' months')::INTERVAL)::DATE; WITH usage_stats AS (SELECT l.supply_id, SUM(ABS(l.quantity_changed)) AS total_consumed FROM public.supply_stock_log l WHERE l.quantity_changed < 0 AND l.created_at >= v_start_date GROUP BY l.supply_id) SELECT json_agg(t.*) INTO report_data FROM (SELECT s.name AS supply_name, COALESCE(us.total_consumed, 0)::int AS total_consumed, s.stock AS current_stock, (COALESCE(us.total_consumed, 0) / p_months)::decimal(10, 2) AS monthly_avg, GREATEST(0, CEIL((COALESCE(us.total_consumed, 0) / p_months) * 3) - s.stock)::int AS suggestion FROM public.office_supplies s LEFT JOIN usage_stats us ON s.id = us.supply_id ORDER BY total_consumed DESC) t; RETURN COALESCE(report_data, '[]'::json); END; $$;

--------------------------------------------------------------------------------
-- 6. TRIGGERS
--------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$ BEGIN INSERT INTO public.employees (id, full_name, registration_number, role) VALUES (new.id, 'Novo Usuário', new.id::text, 'employee'); RETURN new; END; $$;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
